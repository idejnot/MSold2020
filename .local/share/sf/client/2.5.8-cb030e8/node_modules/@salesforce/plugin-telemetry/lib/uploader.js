"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uploader = void 0;
const ts_types_1 = require("@salesforce/ts-types");
const telemetry_1 = require("./telemetry");
const debugger_1 = require("./debugger");
const PROJECT = 'salesforce-cli';
const APP_INSIGHTS_KEY = '2ca64abb-6123-4c7b-bd9e-4fe73e71fe9c';
class Uploader {
    constructor(telemetry) {
        this.telemetry = telemetry;
    }
    /**
     * Sends events from telemetry.
     */
    static async upload(cacheDir, telemetryFilePath) {
        const telemetry = (global.cliTelemetry = await telemetry_1.default.create({ cacheDir, telemetryFilePath }));
        const uploader = new Uploader(telemetry);
        await uploader.sendToTelemetry();
    }
    /**
     * Reads the telemetry events from file and sends them to the telemetry service.
     */
    async sendToTelemetry() {
        const { TelemetryReporter } = await import('@salesforce/telemetry');
        let reporter;
        try {
            reporter = await TelemetryReporter.create({
                project: PROJECT,
                key: APP_INSIGHTS_KEY,
                userId: this.telemetry.getCLIId(),
                waitForConnection: true,
            });
        }
        catch (err) {
            const error = err;
            (0, debugger_1.debug)(`Error creating reporter: ${error.message}`);
            // We can't do much without a reporter, so clear the telemetry file and move on.
            await this.telemetry.clear();
            return;
        }
        try {
            const events = await this.telemetry.read();
            for (const event of events) {
                event.telemetryVersion = debugger_1.version;
                const eventType = (0, ts_types_1.asString)(event.type) ?? telemetry_1.default.EVENT;
                const eventName = (0, ts_types_1.asString)(event.eventName) ?? 'UNKNOWN';
                delete event.type;
                delete event.eventName;
                if (eventType === telemetry_1.default.EVENT) {
                    reporter.sendTelemetryEvent(eventName, event);
                }
                else if (eventType === telemetry_1.default.EXCEPTION) {
                    const error = new Error();
                    // We know this is an object because it is logged as such
                    const errorObject = event.error;
                    delete event.error;
                    Object.assign(error, errorObject);
                    error.name = (0, ts_types_1.asString)(errorObject.name) ?? 'Unknown';
                    error.message = (0, ts_types_1.asString)(errorObject.message) ?? 'Unknown';
                    error.stack = (0, ts_types_1.asString)(errorObject.stack) ?? 'Unknown';
                    reporter.sendTelemetryException(error, event);
                }
            }
        }
        catch (err) {
            const error = err;
            (0, debugger_1.debug)(`Error reading or sending telemetry events: ${error.message}`);
        }
        finally {
            try {
                // We are done sending events
                reporter.stop();
            }
            catch (err) {
                const error = err;
                (0, debugger_1.debug)(`Error stopping telemetry reporter: ${error.message}`);
            }
            finally {
                // We always want to clear the file.
                await this.telemetry.clear();
            }
        }
    }
}
exports.Uploader = Uploader;
//# sourceMappingURL=uploader.js.map