"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const path_1 = require("path");
const fs = require("fs");
const core_1 = require("@salesforce/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const ts_types_1 = require("@salesforce/ts-types");
const source_tracking_1 = require("@salesforce/source-tracking");
const kit_1 = require("@salesforce/kit");
const flags_1 = require("../../../utils/flags");
const retrieveResultFormatter_1 = require("../../../formatters/retrieveResultFormatter");
const metadataRetrieveResultFormatter_1 = require("../../../formatters/metadataRetrieveResultFormatter");
const project_1 = require("../../../utils/project");
const conflicts_1 = require("../../../utils/conflicts");
const promiseQueue_1 = require("../../../utils/promiseQueue");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'retrieve.start');
const mdTransferMessages = core_1.Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'metadata.transfer');
const mdapiFlagGroup = 'Metadata API Format';
class RetrieveMetadata extends sf_plugins_core_1.SfCommand {
    // eslint-disable-next-line complexity
    async run() {
        const { flags } = await this.parse(RetrieveMetadata);
        let resolvedTargetDir;
        if (flags['output-dir']) {
            resolvedTargetDir = (0, path_1.resolve)(flags['output-dir']);
            if (core_1.SfProject.getInstance()?.getPackageNameFromPath(resolvedTargetDir)) {
                throw messages.createError('retrieveTargetDirOverlapsPackage', [flags['output-dir']]);
            }
        }
        const format = flags['target-metadata-dir'] ? 'metadata' : 'source';
        const zipFileName = flags['zip-file-name'] ?? flags_1.DEFAULT_ZIP_FILE_NAME;
        this.spinner.start(messages.getMessage('spinner.start'));
        const { componentSetFromNonDeletes, fileResponsesFromDelete = [] } = await buildRetrieveAndDeleteTargets(flags, format);
        if (flags.manifest || flags.metadata) {
            const access = new source_deploy_retrieve_1.RegistryAccess();
            if (wantsToRetrieveCustomFields(componentSetFromNonDeletes, access)) {
                this.warn(messages.getMessage('wantsToRetrieveCustomFields'));
                componentSetFromNonDeletes.add({
                    fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD,
                    type: access.getTypeByName('CustomObject'),
                });
            }
        }
        const retrieveOpts = await buildRetrieveOptions(flags, format, zipFileName, resolvedTargetDir);
        this.spinner.status = messages.getMessage('spinner.sending');
        this.retrieveResult = new source_deploy_retrieve_1.RetrieveResult({}, componentSetFromNonDeletes);
        if (componentSetFromNonDeletes.size !== 0 || retrieveOpts.packageOptions?.length) {
            // eslint-disable-next-line @typescript-eslint/require-await
            core_1.Lifecycle.getInstance().on('apiVersionRetrieve', async (apiData) => {
                this.log(messages.getMessage('apiVersionMsgDetailed', [
                    'Retrieving',
                    apiData.manifestVersion,
                    flags['target-org'].getUsername(),
                    apiData.apiVersion,
                ]));
            });
            const retrieve = await componentSetFromNonDeletes.retrieve(retrieveOpts);
            this.spinner.status = messages.getMessage('spinner.polling');
            retrieve.onUpdate((data) => {
                this.spinner.status = mdTransferMessages.getMessage(data.status);
            });
            // any thing else should stop the progress bar
            retrieve.onFinish((data) => this.spinner.stop(mdTransferMessages.getMessage(data.response.status)));
            retrieve.onCancel((data) => this.spinner.stop(mdTransferMessages.getMessage(data?.status ?? 'Canceled')));
            retrieve.onError((error) => {
                this.spinner.stop(error.name);
                throw error;
            });
            this.retrieveResult = await retrieve.pollStatus(500, flags.wait.seconds);
        }
        this.spinner.stop();
        // flags['output-dir'] will set resolvedTargetDir var, so this check is redundant, but allows for nice typings in the moveResultsForRetrieveTargetDir method
        if (flags['output-dir'] && resolvedTargetDir) {
            await this.moveResultsForRetrieveTargetDir(flags['output-dir'], resolvedTargetDir);
        }
        // reference the flag instead of `format` so we get correct type
        const formatter = flags['target-metadata-dir']
            ? new metadataRetrieveResultFormatter_1.MetadataRetrieveResultFormatter(this.retrieveResult, {
                'target-metadata-dir': flags['target-metadata-dir'],
                'zip-file-name': zipFileName,
                unzip: flags.unzip,
            })
            : new retrieveResultFormatter_1.RetrieveResultFormatter(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), this.retrieveResult, flags['package-name'], fileResponsesFromDelete);
        if (!this.jsonEnabled()) {
            // in the case where we didn't retrieve anything, check if we have any deletes
            if (!this.retrieveResult.response.status ||
                this.retrieveResult.response.status === 'Succeeded' ||
                fileResponsesFromDelete.length !== 0) {
                await formatter.display();
            }
            else {
                throw new core_1.SfError((0, ts_types_1.getString)(this.retrieveResult.response, 'errorMessage', this.retrieveResult.response.status), (0, ts_types_1.getString)(this.retrieveResult.response, 'errorStatusCode', 'unknown'));
            }
        }
        if (format === 'metadata' && flags.unzip) {
            try {
                await (0, promises_1.rm)((0, path_1.resolve)((0, path_1.join)(flags['target-metadata-dir'] ?? '', zipFileName)), {
                    recursive: true,
                });
            }
            catch (e) {
                // do nothing
            }
        }
        return formatter.getJson();
    }
    catch(error) {
        if (!this.jsonEnabled() && error instanceof source_tracking_1.SourceConflictError) {
            (0, conflicts_1.writeConflictTable)(error.data);
            // set the message and add plugin-specific actions
            return super.catch({
                ...error,
                message: messages.getMessage('error.Conflicts'),
                actions: messages.getMessages('error.Conflicts.Actions', [this.config.bin]),
            });
        }
        return super.catch(error);
    }
    async moveResultsForRetrieveTargetDir(targetDir, resolvedTargetDir) {
        async function mv(src) {
            let directories = [];
            let files = [];
            const srcStat = await fs.promises.stat(src);
            if (srcStat.isDirectory()) {
                const contents = await fs.promises.readdir(src, { withFileTypes: true });
                [directories, files] = contents.reduce((acc, dirent) => {
                    if (dirent.isDirectory()) {
                        acc[0].push(dirent.name);
                    }
                    else {
                        acc[1].push(dirent.name);
                    }
                    return acc;
                }, [[], []]);
                directories = directories.map((dir) => (0, path_1.join)(src, dir));
            }
            else {
                files.push(src);
            }
            await (0, promiseQueue_1.promisesQueue)(files, async (file) => {
                const dest = (0, path_1.join)(src.replace((0, path_1.join)('main', 'default'), ''), file);
                const destDir = (0, path_1.dirname)(dest);
                await fs.promises.mkdir(destDir, { recursive: true });
                await fs.promises.rename((0, path_1.join)(src, file), dest);
                return dest;
            }, 50);
            return directories;
        }
        // getFileResponses fails once the files have been moved, calculate where they're moved to, and then move them
        this.retrieveResult.getFileResponses().forEach((fileResponse) => {
            fileResponse.filePath = fileResponse.filePath?.replace((0, path_1.join)('main', 'default'), '');
        });
        // move contents of 'main/default' to 'retrievetargetdir'
        await (0, promiseQueue_1.promisesQueue)([(0, path_1.join)(resolvedTargetDir, 'main', 'default')], mv, 5, true);
        // remove 'main/default'
        await fs.promises.rm((0, path_1.join)(targetDir, 'main'), { recursive: true });
    }
}
exports.default = RetrieveMetadata;
RetrieveMetadata.summary = messages.getMessage('summary');
RetrieveMetadata.description = messages.getMessage('description');
RetrieveMetadata.examples = messages.getMessages('examples');
RetrieveMetadata.aliases = ['retrieve:metadata'];
RetrieveMetadata.deprecateAliases = true;
RetrieveMetadata.flags = {
    'api-version': sf_plugins_core_1.Flags.orgApiVersion({
        char: 'a',
        summary: messages.getMessage('flags.api-version.summary'),
        description: messages.getMessage('flags.api-version.description'),
    }),
    'ignore-conflicts': sf_plugins_core_1.Flags.boolean({
        char: 'c',
        summary: messages.getMessage('flags.ignore-conflicts.summary'),
        description: messages.getMessage('flags.ignore-conflicts.description'),
        default: false,
    }),
    manifest: sf_plugins_core_1.Flags.file({
        char: 'x',
        summary: messages.getMessage('flags.manifest.summary'),
        description: messages.getMessage('flags.manifest.description'),
        exclusive: ['metadata', 'source-dir'],
        exists: true,
    }),
    metadata: sf_plugins_core_1.Flags.string({
        char: 'm',
        summary: messages.getMessage('flags.metadata.summary'),
        multiple: true,
        exclusive: ['manifest', 'source-dir'],
    }),
    'package-name': sf_plugins_core_1.Flags.string({
        char: 'n',
        summary: messages.getMessage('flags.package-name.summary'),
        multiple: true,
    }),
    'output-dir': sf_plugins_core_1.Flags.directory({
        char: 'r',
        summary: messages.getMessage('flags.output-dir.summary'),
        description: messages.getMessage('flags.output-dir.description'),
        exclusive: ['package-name', 'source-dir'],
    }),
    'single-package': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.single-package.summary'),
        dependsOn: ['target-metadata-dir'],
        exclusive: ['ignore-conflicts'],
        helpGroup: mdapiFlagGroup,
    }),
    'source-dir': sf_plugins_core_1.Flags.string({
        char: 'd',
        summary: messages.getMessage('flags.source-dir.summary'),
        description: messages.getMessage('flags.source-dir.description'),
        multiple: true,
        exclusive: ['manifest', 'metadata'],
    }),
    'target-metadata-dir': (0, flags_1.ensuredDirFlag)({
        char: 't',
        summary: messages.getMessage('flags.target-metadata-dir.summary'),
        relationships: [
            {
                type: 'some',
                flags: ['manifest', 'metadata', 'source-dir', 'package-name'],
            },
        ],
        exclusive: ['ignore-conflicts'],
        helpGroup: mdapiFlagGroup,
    }),
    'target-org': sf_plugins_core_1.Flags.requiredOrg({
        char: 'o',
        summary: messages.getMessage('flags.target-org.summary'),
        description: messages.getMessage('flags.target-org.description'),
        required: true,
    }),
    wait: sf_plugins_core_1.Flags.duration({
        char: 'w',
        defaultValue: 33,
        default: kit_1.Duration.minutes(33),
        unit: 'minutes',
        summary: messages.getMessage('flags.wait.summary'),
        description: messages.getMessage('flags.wait.description'),
    }),
    unzip: sf_plugins_core_1.Flags.boolean({
        char: 'z',
        summary: messages.getMessage('flags.unzip.summary'),
        dependsOn: ['target-metadata-dir'],
        exclusive: ['ignore-conflicts'],
        helpGroup: mdapiFlagGroup,
    }),
    'zip-file-name': (0, flags_1.zipFileFlag)({
        summary: messages.getMessage('flags.zip-file-name.summary'),
        dependsOn: ['target-metadata-dir'],
        exclusive: ['ignore-conflicts'],
        helpGroup: mdapiFlagGroup,
    }),
};
RetrieveMetadata.configurationVariablesSection = (0, sf_plugins_core_1.toHelpSection)('CONFIGURATION VARIABLES', core_1.OrgConfigProperties.TARGET_ORG, core_1.OrgConfigProperties.ORG_API_VERSION);
RetrieveMetadata.envVariablesSection = (0, sf_plugins_core_1.toHelpSection)('ENVIRONMENT VARIABLES', core_1.EnvironmentVariable.SF_TARGET_ORG, core_1.EnvironmentVariable.SF_USE_PROGRESS_BAR);
const wantsToRetrieveCustomFields = (cs, registry) => {
    const hasCustomField = cs.has({
        type: registry.getTypeByName('CustomField'),
        fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD,
    });
    const hasCustomObject = cs.has({
        type: registry.getTypeByName('CustomObject'),
        fullName: source_deploy_retrieve_1.ComponentSet.WILDCARD,
    });
    return hasCustomField && !hasCustomObject;
};
const buildRetrieveAndDeleteTargets = async (flags, format) => {
    const isChanges = !flags['source-dir'] &&
        !flags['manifest'] &&
        !flags['metadata'] &&
        !flags['target-metadata-dir'] &&
        !flags['package-name']?.length;
    if (isChanges) {
        const stl = await source_tracking_1.SourceTracking.create({
            org: flags['target-org'],
            project: await core_1.SfProject.resolve(),
            subscribeSDREvents: true,
            ignoreConflicts: format === 'metadata' || flags['ignore-conflicts'],
        });
        const result = await stl.maybeApplyRemoteDeletesToLocal(true);
        // STL returns a componentSet that gets these from the project/config.
        // if the command has a flag, we'll override
        if (flags['api-version']) {
            result.componentSetFromNonDeletes.apiVersion = flags['api-version'];
        }
        return result;
    }
    else {
        return {
            componentSetFromNonDeletes: await source_deploy_retrieve_1.ComponentSetBuilder.build({
                sourceapiversion: (await (await (0, project_1.getOptionalProject)())?.resolveProjectConfig())?.sourceApiVersion,
                apiversion: flags['api-version'],
                sourcepath: flags['source-dir'],
                packagenames: flags['package-name'],
                ...(flags.manifest
                    ? {
                        manifest: {
                            manifestPath: flags.manifest,
                            // if mdapi format, there might not be a project
                            directoryPaths: format === 'metadata' || flags['output-dir'] ? [] : await (0, project_1.getPackageDirs)(),
                        },
                    }
                    : {}),
                ...(flags.metadata
                    ? {
                        metadata: {
                            metadataEntries: flags.metadata,
                            // if mdapi format, there might not be a project
                            directoryPaths: format === 'metadata' || flags['output-dir'] ? [] : await (0, project_1.getPackageDirs)(),
                        },
                    }
                    : {}),
            }),
        };
    }
};
/**
 *
 *
 * @param flags
 * @param format 'metadata' or 'source'
 * @param zipFileName
 * @param output
 * @returns RetrieveSetOptions (an object that can be passed as the options for a ComponentSet retrieve)
 */
const buildRetrieveOptions = async (flags, format, zipFileName, output) => ({
    usernameOrConnection: flags['target-org'].getUsername() ?? flags['target-org'].getConnection(flags['api-version']),
    merge: true,
    packageOptions: flags['package-name'],
    format,
    ...(format === 'metadata'
        ? {
            singlePackage: flags['single-package'],
            unzip: flags.unzip,
            zipFileName,
            // known to exist because that's how `format` becomes 'metadata'
            output: flags['target-metadata-dir'],
        }
        : {
            output: output ?? (await core_1.SfProject.resolve()).getDefaultPackage().fullPath,
        }),
});
//# sourceMappingURL=start.js.map