"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetrieveResultFormatter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const core_1 = require("@salesforce/core");
const types_1 = require("../utils/types");
const output_1 = require("../utils/output");
class RetrieveResultFormatter {
    constructor(ux, result, packageNames = [], deleteResponses = []) {
        this.ux = ux;
        this.result = result;
        this.packageNames = packageNames;
        this.files = (this.result.getFileResponses() ?? []).concat(deleteResponses);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async getJson() {
        const { zipFile, ...responseWithoutZip } = this.result.response;
        return { ...responseWithoutZip, files: this.files };
    }
    async display() {
        this.displaySuccesses();
        await this.displayPackages();
    }
    displaySuccesses() {
        const successes = (0, output_1.sortFileResponses)((0, output_1.asRelativePaths)(this.files.filter(types_1.isSdrSuccess)));
        if (!successes.length) {
            // a retrieve happened, but nothing was retrieved
            if (this.result.response.status) {
                this.ux.warn('Nothing retrieved');
            }
            else {
                // a retrieve didn't happen, probably because everything was ignored or there were no remote changes to retrieve
                this.ux.log('Nothing retrieved');
            }
            return;
        }
        const columns = {
            state: { header: 'State' },
            fullName: { header: 'Name' },
            type: { header: 'Type' },
            filePath: { header: 'Path' },
        };
        const title = 'Retrieved Source';
        const options = { title: (0, output_1.tableHeader)(title), 'no-truncate': true };
        this.ux.log();
        this.ux.table((0, output_1.getFileResponseSuccessProps)(successes), columns, options);
    }
    async displayPackages() {
        const packages = await this.getPackages();
        if (packages?.length) {
            const columns = {
                name: { header: 'Package Name' },
                fullPath: { header: 'Converted Location' },
            };
            const title = 'Retrieved Packages';
            const options = { title: (0, output_1.tableHeader)(title), 'no-truncate': true };
            this.ux.log();
            this.ux.table(packages, columns, options);
        }
    }
    async getPackages() {
        const projectPath = await core_1.SfProject.resolveProjectPath();
        return this.packageNames.map((name) => {
            const packagePath = path.join(projectPath, name);
            return { name, path: packagePath, fullPath: path.resolve(packagePath) };
        });
    }
}
exports.RetrieveResultFormatter = RetrieveResultFormatter;
//# sourceMappingURL=retrieveResultFormatter.js.map