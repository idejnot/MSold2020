"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Set = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const config_1 = require("../../config");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-settings', 'config.set');
class Set extends sf_plugins_core_1.SfCommand {
    async run() {
        const { args, argv, flags } = await this.parse(Set);
        const config = await loadConfig(flags.global);
        const responses = { successes: [], failures: [] };
        if (!argv.length)
            throw messages.createError('error.ArgumentsRequired');
        const parsed = (0, sf_plugins_core_1.parseVarArgs)(args, argv);
        for (const [name, value] of Object.entries(parsed)) {
            let resolvedName = name;
            try {
                // this needs to be inside the try/catch because it can throw an error
                resolvedName = this.configAggregator.getPropertyMeta(name)?.newKey ?? name;
                if (!value) {
                    // Push a failure if users are try to unset a value with `set=`.
                    responses.failures.push((0, config_1.buildFailureMsg)(name, messages.createError('error.ValueRequired'), value));
                }
                else {
                    // core's builtin config validation requires synchronous functions but there's
                    // currently no way to validate an org synchronously. Therefore, we have to manually
                    // validate the org here and manually set the error message if it fails
                    // eslint-disable-next-line no-await-in-loop
                    if (isOrgKey(resolvedName) && value)
                        await validateOrg(value);
                    config.set(resolvedName, value);
                    responses.successes.push({ name: resolvedName, value, success: true });
                }
            }
            catch (error) {
                if (error instanceof Error && error.name.includes('UnknownConfigKeyError')) {
                    if (this.jsonEnabled()) {
                        responses.failures.push((0, config_1.buildFailureMsg)(resolvedName, error, value));
                    }
                    else {
                        const suggestion = (0, config_1.calculateSuggestion)(name);
                        // eslint-disable-next-line no-await-in-loop
                        const answer = (await this.confirm(messages.getMessage('didYouMean', [suggestion]), 10 * 1000)) ?? false;
                        if (answer && value) {
                            const key = core_1.Config.getPropertyConfigMeta(suggestion)?.key ?? suggestion;
                            config.set(key, value);
                            responses.successes.push({ name: key, value, success: true });
                        }
                    }
                }
                else {
                    responses.failures.push((0, config_1.buildFailureMsg)(resolvedName, error, value));
                }
            }
        }
        await config.write();
        if (responses.failures.length) {
            process.exitCode = 1;
        }
        (0, config_1.output)(new sf_plugins_core_1.Ux({ jsonEnabled: this.jsonEnabled() }), [...responses.successes, ...responses.failures], 'set');
        return responses;
    }
}
exports.Set = Set;
Set.description = messages.getMessage('description');
Set.summary = messages.getMessage('summary');
Set.examples = messages.getMessages('examples');
Set.aliases = ['force:config:set'];
Set.deprecateAliases = true;
Set.strict = false;
Set.flags = {
    loglevel: sf_plugins_core_1.loglevel,
    global: sf_plugins_core_1.Flags.boolean({
        char: 'g',
        summary: messages.getMessage('flags.global.summary'),
    }),
};
Set.configurationVariablesSection = config_1.CONFIG_HELP_SECTION;
const loadConfig = async (global) => {
    try {
        const config = await core_1.Config.create(core_1.Config.getDefaultOptions(global));
        await config.read();
        return config;
    }
    catch (error) {
        if (error instanceof core_1.SfError) {
            error.actions = error.actions ?? [];
            error.actions.push('Run with --global to set for your entire workspace.');
        }
        throw error;
    }
};
const isOrgKey = (name) => [core_1.OrgConfigProperties.TARGET_DEV_HUB, core_1.OrgConfigProperties.TARGET_ORG].includes(name);
const validateOrg = async (value) => {
    try {
        await core_1.Org.create({ aliasOrUsername: value });
    }
    catch {
        throw new Error(`Invalid config value: org "${value}" is not authenticated.`);
    }
};
//# sourceMappingURL=set.js.map