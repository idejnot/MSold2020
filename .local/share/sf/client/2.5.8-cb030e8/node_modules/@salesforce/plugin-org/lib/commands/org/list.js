"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrgListCommand = exports.defaultHubEmoji = exports.defaultOrgEmoji = void 0;
const sf_plugins_core_1 = require("@salesforce/sf-plugins-core");
const core_1 = require("@salesforce/core");
const chalk = require("chalk");
const orgListUtil_1 = require("../../shared/orgListUtil");
const orgHighlighter_1 = require("../../shared/orgHighlighter");
core_1.Messages.importMessagesDirectory(__dirname);
const messages = core_1.Messages.loadMessages('@salesforce/plugin-org', 'list');
exports.defaultOrgEmoji = '🍁';
exports.defaultHubEmoji = '🌳';
class OrgListCommand extends sf_plugins_core_1.SfCommand {
    async run() {
        const [{ flags }, fileNames] = await Promise.all([this.parse(OrgListCommand), getAuthFileNames()]);
        this.flags = flags;
        const metaConfigs = await orgListUtil_1.OrgListUtil.readLocallyValidatedMetaConfigsGroupedByOrgType(fileNames, flags);
        const groupedSortedOrgs = {
            devHubs: metaConfigs.devHubs.map(decorateWithDefaultStatus).sort(comparator),
            other: metaConfigs.other.map(decorateWithDefaultStatus).sort(comparator),
            sandboxes: metaConfigs.sandboxes.map(decorateWithDefaultStatus).sort(comparator),
            nonScratchOrgs: metaConfigs.nonScratchOrgs.map(decorateWithDefaultStatus).sort(comparator),
            scratchOrgs: metaConfigs.scratchOrgs.map(decorateWithDefaultStatus).sort(comparator),
            expiredScratchOrgs: metaConfigs.scratchOrgs.filter((org) => !(0, orgListUtil_1.identifyActiveOrgByStatus)(org)),
        };
        if (flags.clean && groupedSortedOrgs.expiredScratchOrgs.length > 0) {
            await this.cleanScratchOrgs(groupedSortedOrgs.expiredScratchOrgs, !flags['no-prompt']);
        }
        if (groupedSortedOrgs.expiredScratchOrgs.length > 10 && !flags.clean) {
            this.warn(messages.getMessage('deleteOrgs', [groupedSortedOrgs.expiredScratchOrgs.length]));
        }
        const result = {
            other: groupedSortedOrgs.other,
            sandboxes: groupedSortedOrgs.sandboxes,
            nonScratchOrgs: groupedSortedOrgs.nonScratchOrgs,
            devHubs: groupedSortedOrgs.devHubs,
            scratchOrgs: flags.all
                ? groupedSortedOrgs.scratchOrgs
                : groupedSortedOrgs.scratchOrgs.filter(orgListUtil_1.identifyActiveOrgByStatus),
        };
        this.printOrgTable({
            devHubs: result.devHubs,
            other: result.other,
            sandboxes: result.sandboxes,
            scratchOrgs: result.scratchOrgs,
            skipconnectionstatus: flags['skip-connection-status'],
        });
        this.info(`
Legend:  ${exports.defaultHubEmoji}=Default DevHub, ${exports.defaultOrgEmoji}=Default Org ${flags.all ? '' : '     Use --all to see expired and deleted scratch orgs'}`);
        return result;
    }
    async cleanScratchOrgs(scratchOrgs, prompt) {
        if (prompt && (await this.confirm(messages.getMessage('prompt', [scratchOrgs.length]))) === false) {
            return;
        }
        await Promise.all(scratchOrgs.map(async (fields) => {
            try {
                const authInfo = await core_1.AuthInfo.create({ username: fields.username });
                const connection = await core_1.Connection.create({
                    authInfo,
                    configAggregator: {
                        // Force an api version to prevent connection check with the server for expired orgs.
                        getInfo: () => ({ value: '47.0' }),
                    },
                });
                const org = await core_1.Org.create({ aliasOrUsername: fields.username, connection });
                await org.remove();
            }
            catch (e) {
                this.warn(messages.getMessage('cleanWarning', [fields.username, this.config.bin, fields.username]));
                if (e instanceof Error) {
                    const logger = await core_1.Logger.child('org:list');
                    logger.debug(`Error cleaning org ${fields.username}: ${e.message}`);
                }
            }
        }));
    }
    printOrgTable({ devHubs, scratchOrgs, other, sandboxes, skipconnectionstatus, }) {
        if (!devHubs.length && !other.length && !sandboxes.length) {
            this.info(messages.getMessage('noResultsFound'));
            return;
        }
        const allOrgs = [
            ...devHubs
                .map(addType('DevHub'))
                .map(colorEveryFieldButConnectedStatus(chalk.cyanBright))
                .map((row) => (0, orgHighlighter_1.getStyledObject)(row))
                .map(statusToEmoji),
            ...other
                .map(colorEveryFieldButConnectedStatus(chalk.magentaBright))
                .map((row) => (0, orgHighlighter_1.getStyledObject)(row))
                .map(statusToEmoji),
            ...sandboxes
                .map(addType('Sandbox'))
                .map(colorEveryFieldButConnectedStatus(chalk.yellowBright))
                .map((row) => (0, orgHighlighter_1.getStyledObject)(row))
                .map(statusToEmoji),
            ...scratchOrgs
                .map((row) => ({ ...row, type: 'Scratch' }))
                .map(convertScratchOrgStatus)
                .map((row) => (0, orgHighlighter_1.getStyledObject)(row))
                .map(statusToEmoji),
        ];
        this.table(allOrgs.map((org) => Object.fromEntries(Object.entries(org).filter(fieldFilter))), {
            defaultMarker: {
                header: '',
            },
            type: {
                header: 'Type',
            },
            alias: {
                header: 'Alias',
            },
            username: { header: 'Username' },
            orgId: { header: 'Org ID' },
            ...(!skipconnectionstatus ? { connectedStatus: { header: 'Status' } } : {}),
            ...(this.flags.verbose
                ? {
                    instanceUrl: { header: 'Instance URL' },
                    devHubOrgId: { header: 'Dev Hub ID' },
                    createdDate: {
                        header: 'Created',
                        get: (data) => data.createdDate?.split('T')?.[0] ?? '',
                    },
                }
                : {}),
            expirationDate: { header: 'Expires' },
        });
    }
}
exports.OrgListCommand = OrgListCommand;
OrgListCommand.summary = messages.getMessage('summary');
OrgListCommand.examples = messages.getMessages('examples');
OrgListCommand.aliases = ['force:org:list'];
OrgListCommand.deprecateAliases = true;
OrgListCommand.flags = {
    verbose: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.verbose.summary'),
    }),
    all: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.all.summary'),
    }),
    clean: sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.clean.summary'),
    }),
    'no-prompt': sf_plugins_core_1.Flags.boolean({
        char: 'p',
        summary: messages.getMessage('flags.no-prompt.summary'),
        dependsOn: ['clean'],
        aliases: ['noprompt'],
        deprecateAliases: true,
    }),
    'skip-connection-status': sf_plugins_core_1.Flags.boolean({
        summary: messages.getMessage('flags.skip-connection-status.summary'),
        aliases: ['skipconnectionstatus'],
        deprecateAliases: true,
    }),
    loglevel: sf_plugins_core_1.loglevel,
};
const decorateWithDefaultStatus = (val) => ({
    ...val,
    ...(val.isDefaultDevHubUsername ? { defaultMarker: '(D)' } : {}),
    ...(val.isDefaultUsername ? { defaultMarker: '(U)' } : {}),
    ...(val.isDefaultDevHubUsername && val.isDefaultUsername ? { defaultMarker: '(D),(U)' } : {}),
});
const statusToEmoji = (val) => ({
    ...val,
    defaultMarker: val.defaultMarker?.replace('(D)', exports.defaultHubEmoji)?.replace('(U)', exports.defaultOrgEmoji),
});
const EMPTIES_LAST = 'zzzzzzzzzz';
// sort by alias then username
const comparator = (a, b) => {
    const aliasCompareResult = (a.alias ?? EMPTIES_LAST).localeCompare(b.alias ?? EMPTIES_LAST);
    return aliasCompareResult !== 0 ? aliasCompareResult : (a.username ?? EMPTIES_LAST).localeCompare(b.username);
};
const getAuthFileNames = async () => {
    try {
        return ((await core_1.AuthInfo.listAllAuthorizations()) ?? []).map((auth) => auth.username);
    }
    catch (err) {
        const error = err;
        if (error.name === 'NoAuthInfoFound') {
            throw new core_1.SfError(messages.getMessage('noOrgsFound'), 'noOrgsFound', [messages.getMessage('noOrgsFoundAction')]);
        }
        else {
            throw error;
        }
    }
};
const addType = (type) => (val) => ({ ...val, type });
const colorEveryFieldButConnectedStatus = (colorFn) => (row) => Object.fromEntries(Object.entries(row).map(([key, val]) => [
    key,
    typeof val === 'string' && key !== 'connectedStatus' ? colorFn(val) : val,
])
// TS is not smart enough to know this didn't change any types
);
const fieldFilter = ([key]) => [
    'defaultMarker',
    'alias',
    'username',
    'orgId',
    'status',
    'connectedStatus',
    'expirationDate',
    'devHubOrgId',
    'createdDate',
    'instanceUrl',
    'type',
    'createdDate',
].includes(key);
const convertScratchOrgStatus = (row) => ({ ...row, connectedStatus: row.status });
//# sourceMappingURL=list.js.map