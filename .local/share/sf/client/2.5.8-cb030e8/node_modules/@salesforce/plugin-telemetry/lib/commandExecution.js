"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandExecution = void 0;
const core_1 = require("@oclif/core");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const debugger_1 = require("./debugger");
class CommandExecution extends kit_1.AsyncCreatable {
    constructor(options) {
        super(options);
        this.specifiedFlags = [];
        this.specifiedFlagFullNames = [];
        this.deprecatedFlagsUsed = [];
        this.command = options.command;
        this.argv = options.argv;
        this.config = options.config;
    }
    /**
     * @deprecated.  Will always return en empty string.
     */
    static async resolveVCSInfo() {
        return Promise.resolve('');
    }
    toJson() {
        const pluginInfo = this.getPluginInfo();
        return {
            eventName: 'COMMAND_EXECUTION',
            // System information
            platform: this.config.platform,
            shell: this.config.shell,
            arch: this.config.arch,
            nodeEnv: process.env.NODE_ENV,
            nodeVersion: process.version,
            processUptime: process.uptime() * 1000,
            // CLI information
            version: this.config.version,
            channel: this.config.channel,
            executable: this.config.bin,
            origin: this.config.userAgent,
            plugin: pluginInfo.name,
            // eslint-disable-next-line camelcase
            plugin_version: pluginInfo.version,
            command: this.command.id,
            // As the user specified, including short names
            specifiedFlags: this.specifiedFlags.join(' '),
            // Flags the user specified, only the full names
            specifiedFlagFullNames: this.specifiedFlagFullNames.join(' '),
            deprecatedFlagsUsed: this.deprecatedFlagsUsed.join(' '),
            deprecatedCommandUsed: this.deprecatedCommandUsed,
            sfdxEnv: process.env.SFDX_ENV,
            s3HostOverride: process.env.SFDX_S3_HOST,
            npmRegistryOverride: process.env.SFDX_NPM_REGISTRY,
            tool: process.env.SFDX_TOOL,
            interceptorMode: process.env.INTERCEPTOR_MODE,
            // Execution information
            date: new Date().toUTCString(),
            // Don't log status or timestamp as a number, otherwise vscode will think it is a metric
            status: (0, ts_types_1.isNumber)(this.status) ? this.status.toString() : undefined,
            timestamp: String(Date.now()),
            // Salesforce Information
            orgId: this.orgId,
            devhubId: this.devhubId,
            orgApiVersion: this.orgApiVersion,
            devhubApiVersion: this.devhubApiVersion,
        };
    }
    getPluginInfo() {
        return {
            name: this.command.plugin?.name,
            version: this.command.plugin?.version,
        };
    }
    getCommandName() {
        return this.command.id;
    }
    async init() {
        const argv = this.argv;
        const flagDefinitions = this.command.flags ?? {};
        // slice off node or bin path, and the executable path, and then remove anything that's been processed as a flag
        const typedCommand = process.argv
            .splice(2)
            .filter((arg) => !argv.includes(arg))
            .join(':');
        if (this.command.deprecationOptions ||
            (typedCommand !== this.command.id &&
                this.command.aliases?.includes(typedCommand) &&
                this.command.deprecateAliases)) {
            // check the deprecationOptions for cases where we've used OCLIF to point to a replacement
            // check the aliases and deprecated aliases for where we're deprecating in place
            this.deprecatedCommandUsed = typedCommand;
        }
        let flags = {};
        try {
            flags = (await core_1.Parser.parse(argv, {
                flags: flagDefinitions,
                args: this.command.args,
                // @ts-expect-error because varargs is not on SfCommand but is on SfdxCommand
                strict: this.command.strict ?? !this.command.varargs,
            })).flags;
        }
        catch (error) {
            (0, debugger_1.debug)('Error parsing flags');
        }
        this.orgId = flags['target-org'] ? flags['target-org'].getOrgId() : null;
        this.devhubId = flags['target-dev-hub'] ? flags['target-dev-hub'].getOrgId() : null;
        this.orgApiVersion = flags['target-org']
            ? flags['target-org'].getConnection().getApiVersion()
            : null;
        this.devhubApiVersion = flags['target-dev-hub']
            ? flags['target-dev-hub'].getConnection().getApiVersion()
            : null;
        this.determineSpecifiedFlags(argv, flags, flagDefinitions);
    }
    determineSpecifiedFlags(argv, flags, flagDefinitions) {
        // Help won't be in the parsed flags
        const shortHelp = argv.find((arg) => /^-h$/.test(arg));
        const fullHelp = argv.find((arg) => /^--help$/.test(arg));
        if (shortHelp || fullHelp) {
            if (shortHelp) {
                this.specifiedFlags.push('h');
            }
            else {
                this.specifiedFlags.push('help');
            }
            this.specifiedFlagFullNames.push('help');
            // All other flags don't matter if help is specified, so end here.
        }
        else {
            Object.keys(flags).forEach((flagName) => {
                const shortCode = flagDefinitions[flagName] && flagDefinitions[flagName].char;
                // Oclif will include the flag if there is a default, but we only want to add it if the
                // user specified it, so confirm in the argv list.
                if (shortCode && argv.find((arg) => new RegExp(`^-${shortCode}(=.*)?$`).test(arg))) {
                    this.specifiedFlags.push(shortCode);
                    this.specifiedFlagFullNames.push(flagName);
                }
                else if (argv.find((arg) => new RegExp(`^--${flagName}(=.*)?$`).test(arg))) {
                    this.specifiedFlags.push(flagName);
                    this.specifiedFlagFullNames.push(flagName);
                }
                else if (flagDefinitions[flagName].deprecateAliases) {
                    // we can't find the flag as the key (long name) or short char, so it must be a deprecated flag
                    const argvFlags = this.argv.map((a) => a.match(/-([a-zA-Z]+)/g)).map((a) => a?.[0].replace('-', ''));
                    this.deprecatedFlagsUsed.push(flagDefinitions[flagName].aliases?.find((a) => argvFlags.includes(a)) ?? '');
                    this.specifiedFlagFullNames.push(flagName);
                    this.specifiedFlags.push(flagName);
                }
            });
        }
    }
}
exports.CommandExecution = CommandExecution;
//# sourceMappingURL=commandExecution.js.map