"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployResultFormatter = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const path = require("path");
const node_os_1 = require("node:os");
const fs = require("fs");
const core_1 = require("@oclif/core");
const source_deploy_retrieve_1 = require("@salesforce/source-deploy-retrieve");
const core_2 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const apex_node_1 = require("@salesforce/apex-node");
const types_1 = require("../utils/types");
const coverage_1 = require("../utils/coverage");
const output_1 = require("../utils/output");
const testResultsFormatter_1 = require("../formatters/testResultsFormatter");
class DeployResultFormatter extends testResultsFormatter_1.TestResultsFormatter {
    constructor(result, flags) {
        super(result, flags);
        this.result = result;
        this.flags = flags;
        this.absoluteFiles = (0, output_1.sortFileResponses)(this.result.getFileResponses() ?? []);
        this.relativeFiles = (0, output_1.asRelativePaths)(this.absoluteFiles);
        this.testLevel = this.flags['test-level'];
        this.verbosity = this.determineVerbosity();
        this.resultsDir = this.flags['results-dir'] ?? 'coverage';
        this.coverageOptions = (0, coverage_1.getCoverageFormattersOptions)(this.flags['coverage-formatters']);
        this.junit = this.flags.junit;
    }
    async getJson() {
        // only generate reports if test results are presented
        if ((!this.result.response?.numberTestsTotal && !this.flags['test-level']) ||
            this.flags['test-level'] === 'NoTestRun') {
            let testsWarn = '';
            if (this.coverageOptions.reportFormats?.length) {
                testsWarn += `\`--coverage-formatters\` was specified but no tests ran.${node_os_1.EOL}`;
            }
            if (this.junit) {
                testsWarn += `\`--junit\` was specified but no tests ran.${node_os_1.EOL}`;
            }
            // only emit warning if --coverage-formatters or --junit flags were passed
            if (testsWarn.length > 0) {
                testsWarn +=
                    'You can ensure tests run by specifying `--test-level` and setting it to `RunSpecifiedTests`, `RunLocalTests` or `RunAllTestsInOrg`.';
                await core_2.Lifecycle.getInstance().emitWarning(testsWarn);
            }
        }
        if (this.coverageOptions.reportFormats?.length) {
            this.createCoverageReport('no-map');
        }
        if (this.junit) {
            this.createJunitResults();
        }
        if (this.verbosity === 'concise') {
            return {
                ...this.result.response,
                details: {
                    componentFailures: this.result.response.details.componentFailures,
                    runTestResult: this.result.response.details.runTestResult,
                },
                files: this.absoluteFiles.filter((f) => f.state === 'Failed'),
            };
        }
        else {
            return {
                ...this.result.response,
                files: this.absoluteFiles,
                ...(this.result.replacements?.size
                    ? {
                        replacements: Object.fromEntries(this.result.replacements),
                    }
                    : {}),
            };
        }
    }
    display() {
        if (this.verbosity !== 'concise') {
            this.displaySuccesses();
        }
        this.displayFailures();
        this.displayDeletes();
        this.displayTestResults();
        this.maybeCreateRequestedReports();
        this.displayReplacements();
    }
    determineVerbosity() {
        if (this.flags.verbose)
            return 'verbose';
        if (this.flags.concise)
            return 'concise';
        return 'normal';
    }
    maybeCreateRequestedReports() {
        // only generate reports if test results are presented
        if (this.coverageOptions.reportFormats?.length) {
            core_1.ux.log(`Code Coverage formats, [${this.flags['coverage-formatters']?.join(', ')}], written to ${this.resultsDir}/`);
            this.createCoverageReport('no-map');
        }
        if (this.junit) {
            core_1.ux.log(`Junit results written to ${this.resultsDir}/junit/junit.xml`);
            this.createJunitResults();
        }
    }
    createJunitResults() {
        const testResult = this.transformDeployTestsResultsToTestResult();
        if (testResult.summary.testsRan > 0) {
            const jUnitReporter = new apex_node_1.JUnitReporter();
            const junitResults = jUnitReporter.format(testResult);
            const junitReportPath = path.join(this.resultsDir ?? '', 'junit');
            fs.mkdirSync(junitReportPath, { recursive: true });
            fs.writeFileSync(path.join(junitReportPath, 'junit.xml'), junitResults, 'utf8');
        }
    }
    transformDeployTestsResultsToTestResult() {
        if (!this.result.response?.details?.runTestResult) {
            throw new core_2.SfError('No test results found');
        }
        const runTestResult = this.result.response?.details?.runTestResult;
        const numTestsRun = parseInt(runTestResult.numTestsRun, 10);
        const numTestFailures = parseInt(runTestResult.numFailures, 10);
        return {
            summary: {
                commandTimeInMs: 0,
                failRate: ((numTestFailures / numTestsRun) * 100).toFixed(2) + '%',
                failing: numTestFailures,
                hostname: this.flags['target-org']?.getConnection().getConnectionOptions().instanceUrl,
                orgId: this.flags['target-org']?.getConnection().getAuthInfoFields().orgId,
                outcome: '',
                passRate: numTestFailures === 0 ? '100%' : ((1 - numTestFailures / numTestsRun) * 100).toFixed(2) + '%',
                passing: numTestsRun - numTestFailures,
                skipRate: '',
                skipped: 0,
                testExecutionTimeInMs: parseFloat(runTestResult.totalTime),
                testRunId: '',
                testStartTime: new Date().toISOString(),
                testTotalTimeInMs: parseFloat(runTestResult.totalTime),
                testsRan: numTestsRun,
                userId: this.flags['target-org']?.getConnection().getConnectionOptions().userId,
                username: this.flags['target-org']?.getConnection().getUsername(),
            },
            tests: [
                ...(0, coverage_1.mapTestResults)((0, kit_1.ensureArray)(runTestResult.successes)),
                ...(0, coverage_1.mapTestResults)((0, kit_1.ensureArray)(runTestResult.failures)),
            ],
            codecoverage: (0, kit_1.ensureArray)(runTestResult?.codeCoverage).map((cov) => {
                const numLinesUncovered = parseInt(cov.numLocationsNotCovered, 10);
                const [uncoveredLines, coveredLines] = (0, coverage_1.generateCoveredLines)(cov);
                const numLocationsNum = parseInt(cov.numLocations, 10);
                const numLocationsNotCovered = parseInt(cov.numLocationsNotCovered, 10);
                return {
                    // TODO: fix this type in SDR?
                    type: cov.type,
                    apexId: cov.id,
                    name: cov.name,
                    numLinesUncovered,
                    numLinesCovered: parseInt(cov.numLocations, 10) - numLinesUncovered,
                    coveredLines,
                    uncoveredLines,
                    percentage: numLocationsNum > 0
                        ? (((numLocationsNum - numLocationsNotCovered) / numLocationsNum) * 100).toFixed() + '%'
                        : '',
                };
            }),
        };
    }
    createCoverageReport(sourceDir) {
        if (this.resultsDir) {
            const apexCoverage = (0, coverage_1.transformCoverageToApexCoverage)((0, kit_1.ensureArray)(this.result.response?.details?.runTestResult?.codeCoverage));
            fs.mkdirSync(this.resultsDir, { recursive: true });
            const coverageReport = new apex_node_1.CoverageReporter(apexCoverage, this.resultsDir, sourceDir, this.coverageOptions);
            coverageReport.generateReports();
        }
    }
    displayReplacements() {
        if (this.verbosity === 'verbose' && this.result.replacements?.size) {
            const replacements = Array.from(this.result.replacements.entries()).flatMap(([filepath, stringsReplaced]) => stringsReplaced.map((replaced) => ({
                filePath: path.relative(process.cwd(), filepath),
                replaced,
            })));
            core_1.ux.table(replacements, {
                filePath: { header: 'PROJECT PATH' },
                replaced: { header: 'TEXT REPLACED' },
            }, {
                title: (0, output_1.tableHeader)('Metadata Replacements'),
                'no-truncate': true,
            });
        }
    }
    displaySuccesses() {
        const successes = this.relativeFiles.filter((f) => f.state !== 'Failed');
        if (!successes.length || this.result.response.status === source_deploy_retrieve_1.RequestStatus.Failed)
            return;
        const columns = {
            state: { header: 'State' },
            fullName: { header: 'Name' },
            type: { header: 'Type' },
            filePath: { header: 'Path' },
        };
        const title = this.result.response.checkOnly ? 'Validated Source' : 'Deployed Source';
        const options = { title: (0, output_1.tableHeader)(title), 'no-truncate': true };
        core_1.ux.log();
        core_1.ux.table(successes.map((s) => ({ filePath: s.filePath, fullName: s.fullName, type: s.type, state: s.state })), columns, options);
    }
    displayFailures() {
        if (this.result.response.status === source_deploy_retrieve_1.RequestStatus.Succeeded)
            return;
        const failures = this.relativeFiles.filter(types_1.isSdrFailure);
        // .push returns a number, so push here
        failures.push(...(0, kit_1.ensureArray)(this.result.response.details.componentFailures).map((fail) => ({
            problemType: fail.problemType,
            fullName: fail.fullName,
            error: fail.problem,
        })));
        if (!failures.length)
            return;
        const columns = {
            problemType: { header: 'Type' },
            fullName: { header: 'Name' },
            error: { header: 'Problem' },
        };
        const options = { title: (0, output_1.error)(`Component Failures [${failures.length}]`), 'no-truncate': true };
        core_1.ux.log();
        core_1.ux.table(failures.map((f) => ({ problemType: f.problemType, fullName: f.fullName, error: f.error })), columns, options);
    }
    displayDeletes() {
        const deletions = this.relativeFiles.filter(types_1.isSdrSuccess).filter((f) => f.state === 'Deleted');
        if (!deletions.length)
            return;
        const columns = {
            fullName: { header: 'Name' },
            type: { header: 'Type' },
            filePath: { header: 'Path' },
        };
        const options = { title: (0, output_1.tableHeader)('Deleted Source'), 'no-truncate': true };
        core_1.ux.log();
        core_1.ux.table((0, output_1.getFileResponseSuccessProps)(deletions), columns, options);
    }
}
exports.DeployResultFormatter = DeployResultFormatter;
//# sourceMappingURL=deployResultFormatter.js.map