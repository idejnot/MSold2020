"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestResultsFormatter = void 0;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const os = require("os");
const core_1 = require("@oclif/core");
const chalk_1 = require("chalk");
const kit_1 = require("@salesforce/kit");
const types_1 = require("../utils/types");
const output_1 = require("../utils/output");
const coverage_1 = require("../utils/coverage");
class TestResultsFormatter {
    constructor(result, flags) {
        this.result = result;
        this.flags = flags;
        this.testLevel = flags['test-level'];
        this.verbosity = this.determineVerbosity();
    }
    displayTestResults() {
        if (this.testLevel === types_1.TestLevel.NoTestRun || !this.result.response.runTestsEnabled) {
            core_1.ux.log();
            return;
        }
        this.displayVerboseTestFailures();
        if (this.verbosity === 'verbose') {
            this.displayVerboseTestSuccesses();
            this.displayVerboseTestCoverage();
        }
        core_1.ux.log();
        core_1.ux.log((0, output_1.tableHeader)('Test Results Summary'));
        core_1.ux.log(`Passing: ${this.result.response.numberTestsCompleted ?? 0}`);
        core_1.ux.log(`Failing: ${this.result.response.numberTestErrors ?? 0}`);
        core_1.ux.log(`Total: ${this.result.response.numberTestsTotal ?? 0}`);
        const time = this.result.response.details.runTestResult?.totalTime ?? 0;
        if (time)
            core_1.ux.log(`Time: ${time}`);
        // I think the type might be wrong in SDR
        (0, kit_1.ensureArray)(this.result.response.details.runTestResult?.codeCoverageWarnings).map((warning) => core_1.ux.warn(`${warning.name ? `${warning.name} - ` : ''}${warning.message}`));
    }
    determineVerbosity() {
        if (this.flags.verbose)
            return 'verbose';
        return 'normal';
    }
    displayVerboseTestCoverage() {
        const codeCoverage = (0, kit_1.ensureArray)(this.result.response.details.runTestResult?.codeCoverage);
        if (codeCoverage.length) {
            const coverage = codeCoverage.sort((a, b) => (a.name.toUpperCase() > b.name.toUpperCase() ? 1 : -1));
            core_1.ux.log();
            core_1.ux.log((0, output_1.tableHeader)('Apex Code Coverage'));
            core_1.ux.table(coverage.map(coverage_1.coverageOutput), {
                name: { header: 'Name' },
                numLocations: { header: '% Covered' },
                lineNotCovered: { header: 'Uncovered Lines' },
            });
        }
    }
    displayVerboseTestSuccesses() {
        const successes = (0, kit_1.ensureArray)(this.result.response.details.runTestResult?.successes);
        if (successes.length > 0) {
            const testSuccesses = sortTestResults(successes);
            core_1.ux.log();
            core_1.ux.log((0, output_1.success)(`Test Success [${successes.length}]`));
            for (const test of testSuccesses) {
                const testName = (0, chalk_1.underline)(`${test.name}.${test.methodName}`);
                core_1.ux.log(`${output_1.check} ${testName}`);
            }
        }
    }
    displayVerboseTestFailures() {
        if (!this.result.response.numberTestErrors)
            return;
        const failures = (0, kit_1.ensureArray)(this.result.response.details.runTestResult?.failures);
        const failureCount = this.result.response.details.runTestResult?.numFailures;
        const testFailures = sortTestResults(failures);
        core_1.ux.log();
        core_1.ux.log((0, output_1.error)(`Test Failures [${failureCount}]`));
        for (const test of testFailures) {
            const testName = (0, chalk_1.underline)(`${test.name}.${test.methodName}`);
            core_1.ux.log(`â€¢ ${testName}`);
            core_1.ux.log(`  ${(0, chalk_1.dim)('message')}: ${test.message}`);
            if (test.stackTrace) {
                const stackTrace = test.stackTrace.replace(/\n/g, `${os.EOL}    `);
                core_1.ux.log(`  ${(0, chalk_1.dim)('stacktrace')}: ${os.EOL}    ${stackTrace}`);
            }
            core_1.ux.log();
        }
    }
}
exports.TestResultsFormatter = TestResultsFormatter;
function sortTestResults(results) {
    return results.sort((a, b) => {
        if (a.methodName === b.methodName) {
            return a.name.localeCompare(b.name);
        }
        return a.methodName.localeCompare(b.methodName);
    });
}
//# sourceMappingURL=testResultsFormatter.js.map